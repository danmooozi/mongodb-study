### 질문1 #정렬 
MongoDB에서 동일한 컬렉션 내의 필드에 숫자 값과 비숫자 값이 모두 포함된 경우 해당 필드를 기준으로 정렬할 때의 동작은 어떻게 됩니까?

1. 정렬 순서는 값의 사전순을 기준으로 합니다. -> 맞습니다. 
	- 동일한 컬렉션에 숫자 값과 숫자가 아닌 값이 모두 포함된 필드를 정렬할 때 MongoDB는 사전순으로 값을 정렬합니다. 사전순으로 정렬은 문자별로 수행됩니다. 즉, 숫자가 문자열로 처리됩니다. 예를 들어 ["2", "10", "1"] 값이 있는 경우 정렬은 다음 문자를 기준으로 하기 때문에 ["1", "10", "2"]로 정렬됩니다. 

2. 숫자의 문자열 표현. 정렬 순서는 각 필드에서 발견된 첫 번째 값의 유형을 기반으로 합니다. -> 틀렸어요. 
	- MongoDB는 각 필드에 대해 발견된 첫 번째 값 유형을 기준으로 정렬 순서를 지정하지 않습니다. 정렬 동작은 첫 번째 값의 유형에 관계없이 필드의 모든 값에 대해 일관됩니다. 
	
3. 정렬이 실패하고 오류를 반환합니다. -> 틀렸어요.
	- MongoDB는 숫자 값과 숫자가 아닌 값을 모두 사용하여 필드를 정렬할 때 실패하거나 오류를 반환하지 않습니다. 값이 혼합된 유형인 경우에도 지정된 정렬 기준에 따라 정렬 작업을 수행합니다. 

4. 숫자 값이 먼저 정렬된 다음 숫자가 아닌 값이 정렬됩니다. -> 틀렸어요. 
	- MongoDB에서 숫자 값과 숫자가 아닌 값이 혼합된 필드를 정렬할 때 정렬 순서는 유형이 아닌 값의 사전순을 기준으로 합니다. 숫자 값과 숫자가 아닌 값은 문자열 표현을 기준으로 혼합되어 정렬됩니다.

### 질문 12 #데이터모델링 #성능

다음 제약 조건 중 MongoDB 데이터 모델에 영향을 미칠 수 있는 것은 무엇입니까? 모든 정답을 선택하십시오.

1. RAM -> 맞습니다.
	- RAM(무작위 접근 메모리)은 MongoDB의 데이터 모델에 영향을 미치는 하드웨어 제약 조건입니다. MongoDB는 성능과 데이터 캐싱을 위해 메모리를 많이 사용합니다. RAM이 부족하면 쿼리 성능이 느려질 수 있으며, 메모리에 저장할 수 있는 데이터 양이 제한되어 MongoDB 배포의 전반적인 성능에 영향을 미칠 수 있습니다.

3. Network -> 맞습니다.
	- 네트워크도 MongoDB의 데이터 모델에 영향을 미칠 수 있습니다. MongoDB는 데이터가 여러 노드 또는 서버에 분산된 분산 배포를 지원합니다. 이러한 노드 간의 네트워크 지연 시간과 대역폭은 데이터 복제 및 접근 속도에 영향을 미쳐 애플리케이션의 전반적인 성능에 영향을 줄 수 있습니다.

Security & Compliance -> 맞습니다.
	- 보안 및 규정 준수 제약 조건은 데이터 모델을 고려할 때 필수적인 사항입니다. MongoDB는 인증, 접근 제어, 암호화 및 감사와 같은 다양한 보안 기능을 제공합니다. 
	- 데이터 개인정보 보호 규정(GDPR)이나 업계별 표준(HIPAA)과 같은 규정 준수 요구 사항은 데이터 모델에 특정 제약을 부과할 수 있으며, 민감한 데이터가 저장되고 접근되며 보호되는 방식에 대한 지침을 제공할 수 있습니다.

Operating System -> 잘못되었습니다.
	- 운영 체제는 MongoDB 성능에 간접적인 영향을 미칠 수 있지만, 데이터 모델에 직접 영향을 미치는 특정 제약 조건으로 간주되지 않습니다. MongoDB는 여러 운영 체제(예: Windows, Linux, macOS)를 지원하며, 선택한 운영 체제와 호환되는 한 데이터 모델은 본질적으로 그것에 의해 제약되지 않습니다.What is the behavior of MongoDB when sorting on a field that has both numeric and non-numeric values in the same collection?

### 질문 14 #index 
explain() 메서드에서 무엇을 유추할 수 있습니까? 모든 정답을 선택하십시오.

1. 선택된 계획에 사용된 인덱스. -> 맞습니다. 
	- explain() 메서드는 선택된 쿼리 실행 계획에서 사용된 인덱스에 대한 정보를 제공합니다. 이는 쿼리 실행 중에 어떤 인덱스가 사용되었는지를 보여줄 수 있습니다. 이 정보는 쿼리의 효율성과 선택된 인덱스의 효과를 이해하는 데 도움이 됩니다.

2. 정렬 단계가 인덱스에 의해 수행되었는지 또는 메모리에서 수행되었는지 여부. -> 맞습니다. 
	- explain() 메서드는 쿼리의 정렬 단계가 인덱스를 사용하여 수행되었는지 또는 메모리에서 수행되었는지에 대한 세부 정보를 제공할 수 있습니다. 이 정보는 특히 대규모 결과 집합을 정렬할 때 쿼리 성능을 분석하는 데 도움이 됩니다.

3. 쿼리가 거쳐야 하는 모든 단계와 각 단계에서 걸리는 시간, 처리된 문서 수 및 파이프라인의 다음 단계로 반환되는 문서 수에 대한 세부 정보. -> 맞습니다.
	- explain() 메서드는 쿼리 실행 중 거쳐야 하는 모든 단계를 분류하여 제공합니다. 여기에는 각 단계에 소요된 시간, 처리된 문서 수 및 반환된 문서 수 등 관련 통계가 포함됩니다. 이 정보는 쿼리 실행 흐름을 이해하고 잠재적인 성능 병목 현상을 식별하며 쿼리를 최적화하는 데 도움이 됩니다.

4. 이 컬렉션에 대한 모든 사용 가능한 인덱스. -> 틀렸습니다.
	- explain() 메서드는 컬렉션에 대한 모든 사용 가능한 인덱스에 대한 정보를 제공하지 않습니다. 이 메서드는 쿼리 실행 계획과 관련된 세부 정보를 제공하는 데 중점을 두며, 모든 사용 가능한 인덱스를 나열하지는 않습니다.

출처: [MongoDB Docs](https://docs.mongodb.com/manual/reference/method/cursor.explain/)

### 질문 15 #문서관계
MongoDB에서 일대일 관계를 어떻게 표현할 수 있습니까? 모든 정답을 선택하십시오.

1. 문서에 필드를 포함할 수 있습니다. -> 맞습니다.
	- MongoDB에서 일대일 관계를 나타내는 한 가지 방법은 필드를 문서 내에 직접 포함하는 것입니다. 즉, 관련된 필드가 상위 문서 내의 하위 문서 또는 중첩된 객체로 저장됩니다. 이 접근 방식은 단일 쿼리로 모든 관련 데이터를 조회할 수 있게 합니다.

2. 문서에 자식 문서로 필드를 포함할 수 있습니다. -> 맞습니다. 
	- 이 선택지는 관련 필드를 상위 문서 내에 자식 문서로 포함하는 것을 의미합니다. 이렇게 하면 관련 데이터가 상위 문서 내에 포함된 문서로 저장되어, 관련 데이터를 쉽게 조회하고 조작할 수 있습니다.

3. 다른 컬렉션의 단일 문서에 연결할 수 있습니다. -> 맞습니다. 
	- MongoDB에서 일대일 관계를 나타내는 또 다른 방법은 다른 컬렉션의 단일 문서에 연결하는 것입니다. 관련 필드를 포함하는 대신, 상위 문서에 별도의 컬렉션에 있는 관련 문서를 가리키는 참조(예: 고유 식별자 또는 외래 키)를 저장할 수 있습니다. 이 접근 방식은 관련 데이터를 위한 별도의 컬렉션을 유지하면서 두 문서 간의 관계를 설정할 수 있게 합니다.

4. MongoDB에서는 일대일 관계를 나타낼 수 없습니다. -> 틀렸습니다. 
	- MongoDB는 위에서 언급한 접근 방식(필드 포함, 자식 문서로 포함, 다른 컬렉션에 연결)을 사용하여 일대일 관계를 나타낼 수 있습니다.

출처: [MongoDB Docs](https://docs.mongodb.com/manual/tutorial/model-embedded-one-to-one-relationships-between-documents/)

### 질문 17 #구성파일 
MongoDB 구성 파일은 일반적으로 어디에 위치해 있습니까?

1. /etc/mongod.conf -> 맞습니다. 
	- 이는 정답입니다. 왜냐하면 관례적으로 MongoDB 설정 파일은 Unix 계열 시스템에서 일반적으로 /etc/mongod.conf에 위치하기 때문입니다. 이 위치는 많은 Linux 배포판에서 시스템 전체 설정 파일의 표준 위치입니다.

 2. /tmp/mongod.conf -> 틀렸습니다.
	 - /tmp 디렉토리는 일반적으로 임시 파일을 위해 사용되며, MongoDB 설정 파일의 표준 위치가 아닙니다. /tmp에 설정 파일을 저장하는 것은 시스템에 의해 주기적으로 정리될 수 있으므로 권장되지 않습니다.

 3. /home/user/mongod.conf -> 틀렸습니다. 
	 - 이 옵션은 사용자의 홈 디렉토리에 설정 파일을 저장하는 것을 제안합니다. 사용자가 자신의 MongoDB 설정 파일을 홈 디렉토리에 가질 수는 있지만, 이는 MongoDB 시스템 전체 설정 파일의 일반적이거나 표준 위치가 아닙니다.

 4. /bin/mongod.conf -> 틀렸습니다.
	 - /bin 디렉토리는 일반적으로 실행 파일을 위해 예약되어 있으며, MongoDB 설정 파일의 표준 위치가 아닙니다. 설정 파일을 /bin 디렉토리에 두는 것은 관례적이거나 권장되는 방법이 아닙니다.

 5. /var/log/mongod.conf -> 틀렸습니다.
 - /var/log 디렉토리는 일반적으로 로그 파일을 위해 사용되며, 설정 파일을 저장하기 위한 표준 위치가 아닙니다. 설정 파일을 /var/log 디렉토리에 저장하는 것은 MongoDB에 대한 표준 관행이 아닙니다.

### 질문 19 #index 
다음은 영화 컬렉션의 스키마입니다:
```
{     _id: ObjectId,     title: String,     genres: Array,     languages: Array,     year: 32-bit integer }
```
그리고 영화 컬렉션에 대한 다음 인덱스가 있습니다:
`{ title: 1 }`
다음 쿼리 중 주어진 인덱스를 사용하여 정렬 단계를 수행하는 것은 무엇입니까? 모든 정답을 선택하십시오.

1. db.movies.find({}).sort({title: 1}) -> 맞습니다. 
	1. 이 쿼리는 "title" 필드를 기준으로 결과를 오름차순으로 정렬합니다. "title" 필드는 인덱스의 일부이므로, 주어진 "title" 필드 인덱스를 사용하여 정렬을 효율적으로 수행할 수 있습니다.

3. db.movies.find({}).sort({title: -1}) -> 맞습니다. 
	1. 이 쿼리는 "title" 필드를 기준으로 결과를 내림차순으로 정렬합니다. "title" 필드는 인덱스의 일부이므로, 주어진 "title" 필드 인덱스를 사용하여 정렬을 효율적으로 수행할 수 있습니다.

5. db.movies.find({genres: "Drama"}).sort({title: 1}) -> 맞습니다. 
	1. 이 쿼리는 "genres" 필드를 기준으로 문서를 필터링한 다음, "title" 필드를 기준으로 결과를 오름차순으로 정렬합니다. "title" 필드는 인덱스의 일부이며, 쿼리가 정렬 단계에서 인덱스된 필드를 포함하므로 인덱스를 사용하여 효율적으로 정렬할 수 있습니다.

7. db.movies.find({genres: "Drama"}).sort({year: 1}) -> 틀렸습니다. 
	1. 이 쿼리는 "genres" 필드를 기준으로 문서를 필터링한 다음, "year" 필드를 기준으로 결과를 오름차순으로 정렬합니다. "title" 필드에 대한 주어진 인덱스를 사용하여 "year" 필드 기준으로 직접 정렬할 수 없습니다. 따라서 "title" 필드에 대한 인덱스는 이 쿼리에서 사용되지 않습니다.

출처: [MongoDB Indexes](https://docs.mongodb.com/manual/indexes/)


### 질문 28 #클러스터연결 #URI
개발 팀이 Atlas에 호스팅된 MongoDB 클러스터에 연결하도록 애플리케이션을 구성하고 있습니다. 애플리케이션은 안전하게 연결하고 MongoDB의 최신 기능을 사용하며 자동 장애 조치를 통해 높은 트래픽을 처리해야 합니다. 또한 여러 복제본에 읽기 작업을 분산시키기 위해 사용자 정의 읽기 기본 설정을 지정해야 합니다. 이러한 요구 사항에 가장 적합한 MongoDB URI 연결 문자열은 무엇입니까?

정답:

`mongodb+srv://username:password@host/test?retryWrites=true&w=majority&readPreference=nearest`

- 이 URI 문자열은 간소화된 DNS 구성을 위한 mongodb+srv 프로토콜을 사용하며, 쓰기 작업의 자동 재시도를 포함하고, 복제본 간의 읽기 작업을 분산하기 위한 "nearest" 읽기 우선 순위를 지정하며, 고가용성을 보장하기 위해 복제 세트를 사용합니다.

틀린 답변:

`mongodb://username:password@host1,host2,host3/test?readPreference=primaryPreferred

- 이 문자열은 복제 세트에 연결하고 읽기 우선 순위를 지정하지만, DNS 관리를 간소화하는 mongodb+srv 프로토콜을 사용하지 않으며, 자동 장애 조치 기능을 포함하지 않습니다.

`mongodb+srv://username:password@host/test?ssl=true&readPreference=secondary

- 이 URI 문자열은 mongodb+srv 프로토콜과 보안을 위한 SSL을 사용하지만, 읽기 우선 순위로 "secondary"를 지정하여 높은 트래픽 시나리오에 최적의 읽기 작업 분산을 하지 못할 수 있습니다.

`mongodb+srv://username:password@host/test?retryWrites=false&readPreference=primary

- 이 URI 문자열은 mongodb+srv 프로토콜을 사용하지만, 장애 조치 중 쓰기 작업을 처리하는 데 중요한 retryWrites를 비활성화하고, "primary" 읽기 우선 순위를 사용하여 높은 트래픽 상황에서 성능 병목 현상을 초래할 수 있습니다.

### 질문 29 #데이터저장
여러 컬렉션이 있는 MongoDB 데이터베이스를 고려해 보십시오. 여기에는 students 컬렉션과 courses 컬렉션이 포함됩니다. students 컬렉션에는 다음 형식의 문서가 포함됩니다:
```
{
   "_id" : ObjectId("5f5f95aae2e85f9e7b33be5a"),
   "student_name" : "John Doe",
   "student_id" : "S001",
   "enrolled_courses" : [
      "C001",
      "C002"
   ]
}

```
courses 컬렉션에는 다음 형식의 문서가 포함됩니다:
```
{
   "_id" : ObjectId("5f5f95aae2e85f9e7b33be5b"),
   "course_id" : "C001",
   "course_name" : "Introduction to MongoDB"
}

```
다중 값을 단일 필드에 저장하는 데 사용되는 MongoDB 개념은 무엇입니까?

1. 배열 -> 맞습니다. 
	1. 이 답변이 맞는 이유는 배열 개념이 문서의 단일 필드에 여러 값을 저장하는 데 사용되기 때문입니다. 제공된 예제에서, 학생 컬렉션의 `enrolled_courses` 필드는 여러 개의 과정 ID를 포함하는 배열입니다. MongoDB의 배열은 하나의 문서의 필드 내에서 동일하거나 다른 데이터 유형의 여러 값을 저장할 수 있도록 허용합니다.

2. 참조 -> 틀렸습니다. 
	1. 참조 개념은 문서의 단일 필드에 여러 값을 저장하는 데 사용되지 않습니다. 참조는 일반적으로 서로 다른 컬렉션 간의 문서 간 관계를 설정하는 데 사용됩니다. 이 시나리오에서는 `enrolled_courses` 필드가 배열이므로 참조가 아닙니다.

3. 내장 문서 -> 틀렸습니다.
	1. 내장 문서 개념은 하나의 문서 내에 다른 문서를 중첩하여 포함하는 것입니다. 이는 관련 정보를 하나의 문서 내에서 그룹화할 수 있지만, 문서의 단일 필드에 여러 값을 직접적으로 저장하는 것을 다루지는 않습니다. 이 경우, 과정 ID가 학생 문서 내에 내장된 것이 아니라 배열로 저장됩니다.

4. 샤딩 -> 틀렸습니다. 
	1. 샤딩은 MongoDB의 수평 확장과 관련된 개념으로, 데이터가 여러 서버나 샤드에 분산되어 대용량 데이터 세트와 높은 트래픽을 처리하는 데 사용됩니다. 이는 문서의 단일 필드에 여러 값을 저장하는 것과는 직접적으로 관련이 없습니다.

### 질문 31 #쿼리 #aggregation 
다음과 같은 문서 구조를 가진 employees라는 MongoDB 컬렉션을 고려하십시오:
```
{
    "_id" : ObjectId("5f7f39d8dbdfgbcabcabcabc"),
    "name" : "John Doe",
    "age" : 32,
    "position" : "Manager",
    "department" : "Sales",
    "salary" : 60000
}
```
연봉이 $60,000 이상이고 "Sales" 부서에서 근무하는 모든 직원을 찾아야 합니다. 또한 "Sales" 부서의 모든 직원의 평균 연봉을 조회해야 합니다. 가장 효율적인 컬렉션 스캔을 수행하는 쿼리는 무엇입니까?

정답:

```javascript
db.employees.aggregate([
    { $match: { department: "Sales", salary: { $gte: 60000 } } },
    { $group: { _id: "$department", avg_salary: { $avg: "$salary" } } }
]);
```

이 쿼리는 가장 효율적인 방법입니다. `department`가 "Sales"이고 `salary`가 60,000 이상인 문서만 필터링한 후, 부서별로 평균 급여를 계산합니다. 이렇게 하면 불필요한 문서가 처리되지 않으므로 성능이 좋습니다.

틀린 답변들:

```javascript
db.employees.find({
    department: "Sales",
    salary: { $gte: 60000 }
}).forEach(function(doc) {
    // process the documents
});
```

이 옵션은 컬렉션 스캔을 수행하고 지정된 조건과 일치하는 모든 문서를 조회하여 처리합니다. 컬렉션이 큰 경우 성능이 저하될 수 있습니다.

```javascript
db.employees.aggregate([
    { $match: { department: "Sales" } },
    { $group: { _id: "$department", avg_salary: { $avg: "$salary" } } },
    { $match: { avg_salary: { $gte: 60000 } } }
]);
```

이 옵션은 컬렉션 스캔을 수행하고, 지정된 조건을 일치시킨 후 결과를 부서별로 그룹화하고 각 부서의 평균 급여를 계산한 다음, 계산된 평균 급여를 다시 일치시키는 방식입니다. 이 방법은 불필요한 중복 처리가 포함되어 성능이 떨어질 수 있습니다.

```javascript
db.employees.aggregate([
    { $match: { department: "Sales" } },
    { $group: { _id: "$department", avg_salary: { $avg: "$salary" } } },
    { $project: { _id: 0, avg_salary: { $gte: [ "$avg_salary", 60000 ] } } }
]);
```

이 옵션은 컬렉션 스캔을 수행하고, 지정된 조건으로 문서를 필터링한 후 결과를 부서별로 그룹화하고 각 부서의 평균 급여를 계산합니다. 이후, 프로젝션을 적용하는데 `$gte` 연산자를 올바르게 사용하지 않아 예상 결과를 반환하지 않습니다.

> 이 문제는 아직도 이해가 되지 않음. 영어실력 문제인지, 모든 임원들을 찾은 결과도 리턴해줘야하는줄알았음

### 질문 32 #aggregation #pipeline
MongoDB Aggregation Framework와 파이프라인에 관한 다음 문장 중 올바른 것은 무엇입니까? 두 개의 정답을 선택하십시오.

1. 집계 파이프라인에는 `$match`, `$group`, `$project`, `$sort`와 같은 단계가 포함될 수 있습니다. -> 맞습니다. 
	1. 집계 파이프라인은 여러 단계를 포함할 수 있으며, 그 중 일부 일반적인 단계로는 `$match`, `$group`, `$project`, `$sort`가 있습니다. 이러한 단계들은 집계 과정에서 문서를 필터링하고, 그룹화하며, 필드를 투영하고, 정렬하는 데 사용됩니다.
2. `$unwind` 단계는 입력 문서의 배열 필드를 분해하여 배열의 각 요소에 대해 새로운 문서를 생성합니다. -> 맞습니다. 
	1. `$unwind` 단계는 입력 문서의 배열 필드를 분해하여 배열의 각 요소에 대해 새로운 문서를 생성합니다. 이는 파이프라인 내에서 개별 배열 요소에 대한 추가 작업에 유용합니다.
3. 집계 파이프라인은 원본 컬렉션의 구조를 수정할 수 있습니다. -> 틀렸습니다.
	1. 집계 파이프라인은 원본 컬렉션의 구조를 수정하지 않습니다. 대신, 지정된 단계에 기반하여 새로운 결과 집합을 생성하며 원본 데이터에는 영향을 미치지 않습니다.

4. 집계 파이프라인은 여러 컬렉션 간의 SQL과 유사한 조인을 지원합니다. -> 틀렸습니다.
	1. MongoDB의 집계 파이프라인은 SQL과 유사한 조인을 지원하지 않습니다. 대신, MongoDB는 `$lookup` 단계와 같은 다른 메커니즘을 제공하여 유사한 작업을 수행할 수 있습니다.
5. `$limit` 단계는 집계 파이프라인에서 지정된 수의 문서를 건너뛰는 데 사용됩니다. -> 틀렸습니다.
	1. `$limit` 단계는 집계 파이프라인에서 반환되는 문서의 수를 지정된 수로 제한하는 데 사용됩니다. 문서를 건너뛰는 것이 아니라 결과 집합에서 문서의 총 수를 제한합니다.
> 이 문제도 어이없음, 유사한 조인 지원이 맞냐해서 고른건데
### 질문 33 #컬렉션 #문서관계 
MongoDB에서 문서와 컬렉션 간의 관계를 올바르게 설명한 문장은 무엇입니까?
1. 컬렉션은 MongoDB 문서의 그룹이며, 관계형 데이터베이스 관리 시스템(RDBMS)의 테이블과 동등합니다. -> 맞습니다. 
	1. MongoDB에서 컬렉션은 문서의 그룹입니다. 컬렉션 내의 문서들은 서로 다른 필드를 가질 수 있지만, 보통은 유사하거나 관련된 목적을 가지고 있습니다. 이는 관계형 데이터베이스 관리 시스템(RDBMS)의 테이블과 유사한 개념입니다.
2. 컬렉션은 오직 하나의 문서만 포함할 수 있습니다. -> 틀렸습니다.
	1. MongoDB의 컬렉션은 하나 이상의 문서를 포함할 수 있습니다. 실제로, 하나의 컬렉션은 수백만 개의 문서를 포함할 수 있습니다.
3. 문서는 여러 컬렉션을 포함할 수 있습니다. -> 틀렸습니다.
	1. 문서는 MongoDB의 레코드이며, 컬렉션을 포함하지 않습니다. 관계는 반대입니다; 컬렉션이 문서를 포함합니다.
4. 컬렉션은 문서를 계층 구조로 조직하고 저장하는 데 사용됩니다. -> 틀렸습니다. 
	1. 컬렉션은 문서를 조직하고 저장하는 데 사용되지만, 계층 구조를 강제하지 않습니다. SQL 데이터베이스와 달리, MongoDB는 컬렉션 내 문서의 특정 구조를 강제하지 않는 유연한 스키마를 가지고 있습니다.

### 질문 41 #데이터모델링 #설계
대학생들이 여러 과목에 등록할 수 있고 각 과목에는 여러 학생이 등록할 수 있는 다양한 과목을 제공하는 대학을 위한 MongoDB 데이터베이스를 설계하고 있습니다. 대학은 각 학생이 등록한 과목과 각 과목에 등록한 학생을 추적해야 합니다. 이 요구 사항에 가장 적합한 데이터 모델은 무엇입니까?

1. 학생 정보를 위한 하나의 컬렉션, 강좌 정보를 위한 하나의 컬렉션, 그리고 각 등록 문서가 학생과 강좌에 대한 참조를 포함하는 하나의 등록 컬렉션을 사용하는 방법 -> 맞습니다. 
	1. 이 옵션은 학생, 강좌, 등록에 관한 정보를 각각 별도의 컬렉션으로 분리하고, 각 등록 문서가 학생과 강좌에 대한 참조를 포함하도록 합니다. 이를 통해 특정 학생의 강좌나 특정 강좌의 학생에 대한 정보를 효율적으로 검색할 수 있으며, 등록 정보에 대한 업데이트도 효율적으로 수행할 수 있습니다.
2. 학생을 위한 하나의 컬렉션을 사용하고, 각 학생 문서에 그들이 등록한 강좌에 대한 참조 배열을 포함시키는 방법 -> 틀렸습니다. 
	1. 이 옵션은 각 학생 문서 내에 등록한 강좌에 대한 정보를 배열로 저장하는 방법을 제안합니다. 배열이 커지고 복잡해질 경우 성능 문제가 발생할 수 있습니다.
3. 학생을 위한 하나의 컬렉션을 사용하고, 각 학생 문서에 그들이 등록한 강좌에 대한 내장 문서 배열을 포함시키는 방법 -> 틀렸습니다.
	1. 이 옵션은 각 학생 문서 내에 등록한 강좌 정보를 내장 문서로 저장하는 방법을 제안합니다. 문서가 커지고 복잡해질 경우 성능 문제가 발생할 수 있습니다.
4. 강좌를 위한 하나의 컬렉션을 사용하고, 각 강좌 문서에 강좌에 등록된 학생에 대한 참조 배열을 포함시키는 방법 -> 틀렸습니다.
	1. 이 옵션은 강좌 문서 내에 강좌에 등록된 학생에 대한 정보를 배열로 저장하는 방법을 제안합니다. 특정 학생의 강좌 정보를 검색할 때 성능 문제가 발생할 수 있습니다.

### 질문 42 #aggregation #pipeline 
고객 ID와 주문을 조인하여 모든 주문과 해당 고객 이름을 조회하는 쿼리를 최적화해야 합니다. 다음 중 원하는 결과를 효율적으로 달성할 수 있는 집계 파이프라인은 무엇입니까?

정답:

```javascript
db.orders.aggregate([
  { $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "customer_id",
      as: "customer_info"
  }}
])
```

이 파이프라인은 `$lookup`을 사용하여 `orders`와 `customers` 컬렉션을 `customer_id` 필드를 기준으로 조인하며, 모든 주문과 해당 고객 정보를 가져옵니다.

오답:

```javascript
db.orders.aggregate([
  { $lookup: {
      from: "customers",
      localField: "order_id",
      foreignField: "customer_id",
      as: "customer_info"
  }}
])
```

`localField`와 `foreignField` 값이 불일치합니다; `order_id`는 `customer_id`와 조인하는 데 적절하지 않습니다.

```javascript
db.orders.aggregate([
  { $lookup: {
      from: "customers",
      pipeline: [{ $match: { "customer_id": "$customer_id" } }],
      as: "customer_info"
  }}
])
```

여기서는 `$lookup`의 파이프라인에서 외부 문서의 변수(`$customer_id`)를 사용하는 것을 시도하고 있는데, 이는 지원되지 않습니다.

```javascript
db.customers.aggregate([
  { $lookup: {
      from: "orders",
      localField: "customer_id",
      foreignField: "customer_id",
      as: "order_info"
  }}
])
```

이 파이프라인은 `customers` 컬렉션을 기준으로 시작하여, 고객과 그들의 주문을 반환합니다. 이는 주문과 고객 정보를 가져오는 목적에 부합하지 않습니다.

### 질문 45
MongoDB 드라이버가 관리하는 연결 풀링과 관련된 다음 진술 중 올바른 것은 무엇입니까?

1. 연결 풀링은 클라이언트 애플리케이션이 MongoDB 데이터베이스와 연결하고 상호작용할 수 있도록 소켓의 풀을 생성하고 관리하는 과정입니다. -> **정확함**. 
	1. MongoDB에서 연결 풀링은 소켓(즉, 연결)의 풀을 생성하고 관리하는 것을 포함합니다. 이러한 연결은 다양한 클라이언트 애플리케이션이 MongoDB 데이터베이스와 상호작용하는 데 사용됩니다. 각 요청에 대해 연결을 열고 닫는 것이 자원과 시간 측면에서 비용이 많이 들기 때문에 성능이 향상됩니다.

2. 연결 풀링은 여러 클라이언트 애플리케이션이 동시에 하나의 데이터베이스 연결을 사용할 수 있게 하여 전체 시스템 성능을 향상시킵니다. -> **부정확함**.
	1. 연결 풀링에서는 하나의 연결을 여러 클라이언트 애플리케이션이 동시에 사용할 수 없습니다. 대신, 여러 개의 연결이 풀에서 관리되며, 각 클라이언트는 이 풀에서 자신의 연결을 가져옵니다.

3. MongoDB의 연결 풀링은 매 클라이언트 요청마다 새로운 연결을 생성하고 요청이 처리된 후에는 이를 폐기합니다. -> **부정확함**.
	1. 연결 풀링의 실제 목적은 매 요청마다 새로운 연결을 생성하는 것이 아니라, 기존 연결을 재사용하는 것입니다. 새로운 연결을 생성하고 이를 처리 후 폐기하는 데 따르는 자원과 시간의 오버헤드를 줄이기 위해 기존 연결을 재사용합니다.

4. MongoDB의 연결 풀링은 유휴 연결을 지원하지 않으며, 즉 연결이 사용되지 않을 경우 즉시 종료됩니다. -> **부정확함**.
	1. MongoDB의 연결 풀링은 유휴 연결을 지원합니다. 유휴 연결은 열려 있지만 현재 사용 중이지 않은 연결로, 향후 사용을 위해 풀에서 유지됩니다. 즉시 종료되지는 않습니다.

### 질문 46 #메서드 #mongoShell
데이터베이스 명령을 실행하는 메서드는 무엇입니까? (Mongo shell)

`db.runCommand({ <command> })` -> **정확함**. 이 방법은 MongoDB 셸에서 데이터베이스 명령을 실행합니다. 여기서 `<command>`는 실행할 특정 명령을 나타냅니다. `runCommand` 메서드를 사용하여 데이터베이스 명령을 실행하는 올바른 구문입니다.

[MongoDB `db.runCommand` 문서](https://docs.mongodb.com/manual/reference/method/db.runCommand/)

### 질문 47 #obejctId
MongoDB에서 삽입 작업을 수행할 때 _id 필드와 관련된 다음 진술 중 올바른 것은 무엇입니까? 모든 정답을 선택하십시오.

1. MongoDB automatically assigns a unique `_id` field value for each document if it is not specified in the insert operation. -> **정확함**.
	1. `_id` 필드를 명시하지 않고 문서를 삽입하면 MongoDB는 자동으로 고유한 `_id` 값을 생성하고 할당합니다.

2. If desired, you can assign your own value to the `_id` field during an insert operation. -> **정확함**. 
	1. 삽입 작업 중에 `_id` 필드에 원하는 값을 직접 할당할 수 있습니다. 이 값은 유효한 BSON 타입이어야 하며, 컬렉션 내에서 고유해야 합니다.

3. MongoDB allows multiple documents in a collection to have the same `_id`. -> **부정확함**.
	1. `_id` 필드는 MongoDB 문서의 기본 키 역할을 하며, 컬렉션 내 모든 문서는 고유한 `_id` 값을 가져야 합니다.

4. The `_id` field in MongoDB can only be of type `ObjectId`. -> **부정확함**.
	1. `_id` 필드는 반드시 `ObjectId` 타입일 필요는 없습니다. 이 필드는 정수(int), 문자열(string) 등 유효한 BSON 타입일 수 있으며, 배열을 제외한 어떤 BSON 타입도 사용할 수 있습니다.

6. The `_id` field is optional and can be omitted in a document. -> **부정확함**.
	1. `_id` 필드는 문서에서 선택 사항이 아니며, 제공하지 않으면 MongoDB가 자동으로 고유한 값을 할당합니다.

### 질문 48 #aggregation #unwind
다음과 같은 문서가 있는 students라는 컬렉션을 고려하십시오:
```
{
   "_id" : ObjectId("5f0a7e80d8c9c7b5a48c49e1"),
   "student_id" : 101,
   "name" : "John Doe",
   "gender" : "Male",
   "age" : 20,
   "scores" : [
      {
         "subject" : "Math",
         "score" : 85
      },
      {
         "subject" : "English",
         "score" : 90
      }
   ]
}

{
   "_id" : ObjectId("5f0a7e80d8c9c7b5a48c49e2"),
   "student_id" : 102,
   "name" : "Jane Doe",
   "gender" : "Female",
   "age" : 22,
   "scores" : [
      {
         "subject" : "Math",
         "score" : 80
      },
      {
         "subject" : "English",
         "score" : 95
      }
   ]
}

{
   "_id" : ObjectId("5f0a7e80d8c9c7b5a48c49e3"),
   "student_id" : 103,
   "name" : "Bob Smith",
   "gender" : "Male",
   "age" : 21,
   "scores" : [
      {
         "subject" : "Math",
         "score" : 90
      },
      {
         "subject" : "English",
         "score" : 88
      }
   ]
}

```
students 컬렉션에서 모든 학생의 각 과목에 대한 평균 점수를 조회하는 쿼리는 무엇입니까?

Here is the translation of the explanation for the correct and incorrect answers:

---

**정답:**

```javascript
db.students.aggregate([
   {
      $unwind: "$scores"
   },
   {
      $group: {
         _id: "$scores.subject",
         average_score: { $avg: "$scores.score" }
      }
   }
])
```

이 쿼리에 대한 설명은 다음과 같습니다:

- **$unwind: "$scores"**: 이 단계는 `scores` 배열 필드를 분해하여 배열 내의 각 요소에 대해 별도의 문서를 생성합니다. 이를 통해 개별 점수에 대한 계산을 수행할 수 있습니다.
  
- **$group**: 이 단계는 `_id` 필드를 "$scores.subject"로 설정하여 문서를 그룹화합니다. 주제별로 문서를 그룹화하고 각 그룹에 대해 집계 연산을 수행할 수 있습니다.

- **average_score: { $avg: "$scores.score" }**: `$group` 단계 내에서 `$avg` 집계 연산자를 사용하여 각 주제에 대한 평균 점수를 계산합니다. `"$scores.score"`는 `scores` 배열 내의 점수 값을 나타냅니다.

**부정확한 답변들:**

```javascript
db.students.aggregate([
   {
      $group: {
         _id: "$scores.subject",
         average_score: { $avg: "$scores.score" }
      }
   }
])
```

이 쿼리는 `scores`가 배열로 저장된 사실을 고려하지 않습니다. `scores` 배열을 분해하지 않으면 `$avg` 연산자는 전체 배열을 대상으로 작동하게 되어 각 주제에 대한 평균 점수를 잘못 계산할 수 있습니다.

```javascript
db.students.aggregate([
   {
      $push: "$scores"
   },
   {
      $group: {
         _id: "$scores.subject",
         average_score: { $avg: "$scores.score" }
      }
   }
])
```

이 쿼리는 `scores` 필드에 `$push` 연산자를 사용합니다. `$push` 연산자는 배열 필드에 값을 추가하는 데 사용되지만, 이 경우 배열의 배열 scores1, scores2, ..을 생성하게 되어 평균 점수를 올바르게 계산할 수 없습니다.

3. 

```javascript
db.students.aggregate([
   {
      $unwind: "$scores"
   },
   {
      $group: {
         _id: "$subject",
         average_score: { $avg: "$score" }
      }
   }
])
```

이 쿼리는 `$group` 단계에서 `"$subject"`와 `"$score"` 필드를 참조하지만, 이 필드들이 `scores` 하위 문서 내에 있다는 것을 고려하지 않았습니다. 올바른 참조는 `"$scores.subject"`와 `"$scores.score"`이어야 합니다. 따라서 이 쿼리는 평균 점수를 정확하게 계산하지 못합니다.

[참고 링크](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/)

> unwind를 제대로 이해하지 못함

### 질문 50 #aggregation 
다음과 같은 구조를 가진 문서를 포함하는 전자 상거래 웹사이트의 제품 정보를 나타내는 컬렉션이 있는 MongoDB 데이터베이스를 고려하십시오:
```
{
   "_id": ObjectId("5f95a1d11a12b400001b75c0"),
   "product_name": "Smartphone",
   "brand": "Apple",
   "price": 800,
   "categories": [ "Electronics", "Smartphones" ],
   "reviews": [
      { "username": "user1", "rating": 4, "comment": "Great product!" },
      { "username": "user2", "rating": 5, "comment": "Excellent!" },
      { "username": "user3", "rating": 3, "comment": "Good but overpriced." }
   ]
}
```
브랜드별 평균 평점을 반환하는 MongoDB 집계 파이프라인을 선택하십시오. 결과에는 평균 평점이 4 이상인 브랜드만 포함되어야 합니다. 출력 형식은 다음과 같아야 합니다:

```
{ "brand": "Apple", "avg_rating": 4.33 }
```

**정답:**

```json
[
   {
      "$unwind": "$reviews"
   },
   {
      "$group": {
         "_id": "$brand",
         "avg_rating": { "$avg": "$reviews.rating" }
      }
   },
   {
      "$match": {
         "avg_rating": { "$gte": 4 }
      }
   },
   {
      "$project": {
         "brand": "$_id",
         "avg_rating": "$avg_rating",
         "_id": 0
      }
   }
]
```

이 쿼리는 다음과 같은 집계 파이프라인 단계를 올바르게 적용하여 원하는 결과를 얻습니다:

- **$unwind**: 이 단계는 `reviews` 배열을 분해하여 각 리뷰에 대해 별도의 문서를 생성합니다. 이를 통해 개별 리뷰에 대해 집계 연산을 수행할 수 있습니다.

- **$group**: 이 단계는 `brand` 필드를 기준으로 문서를 그룹화하고 `reviews.rating`에 대해 `$avg` 연산자를 사용하여 각 브랜드에 대한 평균 평가 점수를 계산합니다.

- **$match**: 이 단계는 `avg_rating` 필드를 기준으로 그룹화된 문서를 필터링하여 평균 평가 점수가 4 이상인 문서만 선택합니다.

- **$project**: 이 단계는 출력 문서를 재구성하여 `_id` 필드를 `brand`로 이름을 바꾸고, 최종 출력에서 `_id` 필드를 제외합니다.

**부정확한 답변들:**

1. 

```json
[
   {
      "$group": {
         "_id": "$brand",
         "avg_rating": { "$avg": "$reviews.rating" }
      }
   },
   {
      "$match": {
         "avg_rating": { "$gte": 4 }
      }
   },
   {
      "$project": {
         "brand": "$_id",
         "avg_rating": "$avg_rating",
         "_id": 0
      }
   }
]
```

이 쿼리는 `$unwind` 단계를 생략하여 `reviews` 배열을 처리하지 않습니다. 배열을 분해하지 않으면 `$avg` 연산자가 올바르게 작동하지 않아 평균 평가 점수가 잘못 계산됩니다.

2. 

```json
[
   {
      "$unwind": "$reviews"
   },
   {
      "$group": {
         "_id": "$brand",
         "avg_rating": { "$avg": "$reviews.rating" }
      }
   },
   {
      "$project": {
         "brand": "$_id",
         "avg_rating": "$avg_rating",
         "_id": 0
      }
   }
]
```

이 쿼리는 `$match` 단계를 포함하지 않아 평균 평가 점수가 4 미만인 브랜드를 필터링하지 않습니다. 질문에서는 평균 평가 점수가 4 이상인 브랜드만 필요하므로 `$match` 단계가 필요합니다.

3. 

```json
[
   {
      "$unwind": "$reviews"
   },
   {
      "$group": {
         "_id": "$brand",
         "avg_rating": { "$avg": "$reviews.rating" }
      }
   },
   {
      "$match": {
         "avg_rating": { "$gte": 4 }
      }
   }
]
```

이 쿼리는 `$project` 단계를 포함하지 않아 출력 문서를 필요한 형식으로 재구성하지 않습니다. 질문에서는 출력이 `{ "brand": "Apple", "avg_rating": 4.33 }` 형식이어야 한다고 명시되어 있으므로 `$project` 단계가 필요합니다.

### 질문 58 #bulkwrite
bulk write 작업을 사용하여 sales라는 MongoDB 컬렉션에 여러 문서를 삽입하는 올바른 구문은 무엇입니까?

다음은 MongoDB의 `bulkWrite` 연산에 대한 올바른 및 잘못된 답변에 대한 설명입니다:

**정답:**

```javascript
db.sales.bulkWrite([
  { insertOne: { name: "Product A", quantity: 10 } },
  { insertOne: { name: "Product B", quantity: 5 } }
])
```

**설명:**
- **`bulkWrite()`** 메서드는 여러 개의 쓰기 작업을 한꺼번에 수행할 때 사용되며, 효율성과 성능을 향상시킵니다.
- `bulkWrite()` 메서드 내에 배열로 쓰기 작업 목록(예: `insertOne`, `updateOne`, `deleteOne`)을 제공합니다.
- 각 쓰기 작업은 객체로 감싸서 배열 내에 배치해야 합니다.

**잘못된 답변:**

1.

```javascript
db.sales.bulkWrite({
  insertOne: [
    { name: "Product A", quantity: 10 },
    { name: "Product B", quantity: 5 }
  ]
})
```

**문제:**
- `insertOne` 연산은 각 문서에 대해 개별적으로 사용해야 합니다. 이 시도는 여러 문서를 단일 `insertOne` 연산으로 결합하려고 하여 잘못된 것입니다.
- 올바른 구문은 각 문서를 개별 연산으로 배열 내에 배치하는 것입니다.

2.

```javascript
db.sales.insertMany(
  [
    { name: "Product A", quantity: 10 },
    { name: "Product B", quantity: 5 }
  ],
  { bulkWrite: true }
)
```

**문제:**
- `insertMany()`는 여러 문서를 한꺼번에 삽입하는 메서드이며, `bulkWrite` 옵션을 사용하지 않습니다.
- `bulkWrite` 옵션은 `insertMany()`에서 유효하지 않습니다.

3.

```javascript
db.sales.bulkWrite({
  insertMany: [
    { name: "Product A", quantity: 10 },
    { name: "Product B", quantity: 5 }
  ]
})
```

**문제:**
- `insertMany`는 `bulkWrite()`에 유효한 연산이 아닙니다. `bulkWrite()` 메서드는 `insertMany`를 연산으로 받아들이지 않습니다.
- 올바른 사용 방법은 `insertOne`, `updateOne`, `deleteOne` 등과 같은 연산을 `bulkWrite()` 메서드 내에서 사용하는 것입니다.

`bulkWrite()`에 대한 자세한 정보는 [MongoDB 공식 문서](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/)에서 확인할 수 있습니다.
