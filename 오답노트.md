### 영어 이슈로 틀린 문제

- 고유 인덱스는 필드가 프로젝션에서 제외되었는지 여부에 관계없이 적용됩니다.

### aggregation 쓸 때 `$`  를 빼먹지 말자.

1. $match stage: This stage filters out documents where the "imdb.rating" field is not an empty string (""). The $ne operator stands for "not equal" and ensures that only documents with non-empty IMDb ratings are considered for aggregation.
2. $group stage: This stage groups all the documents together using _id: null, meaning there is no specific grouping criteria. The $group stage then performs the following aggregations on the grouped documents:
    - $avg: Calculates the average of the "imdb.rating" field across all documents in the group.
    - $min: Finds the minimum value of the "imdb.rating" field in the group.
    - $max: Finds the maximum value of the "imdb.rating" field in the group.
- $count

`ordersDatabase` 몽고 디비는 컬렉션 이름 할때 camelCase 가 정석이다.

### 1:1 참조 관계일 때, 별도로 유지하는 것이 어떤 장단을 같는지

참조 관계를 사용하여 MongoDB에서 관계를 모델링할 때 종종 각 엔터티에 대해 별도의 컬렉션을 사용하는 것이 유익합니다. 이 접근 방식은 컬렉션을 독립적으로 관리하고 업데이트할 수 있으므로 유지 관리성을 개선할 수 있습니다. 또한 별도의 컬렉션을 사용하면 각 컬렉션이 고유한 업데이트 및 데이터 변경 세트를 가질 수 있으므로 관련 엔터티에 대한 업데이트의 복잡성도 줄일 수 있습니다. 이는 엔터티 간에 여러 관계가 있는 대규모 복잡한 애플리케이션에서 특히 유용할 수 있습니다. 그러나 별도의 컬렉션을 사용하면 쿼리 성능이 저하되고 조인이 더 많이 필요하다는 등의 단점이 있을 수 있다는 점에 유의하는 것이 중요합니다. 

### 1:N 관계일때,

것은 MongoDB에서 일대다 관계를 표현하는 데 가장 좋은 데이터 모델링 기술로 간주됩니다. 왜냐하면 관련 데이터를 효율적이고 정확하게 검색할 수 있고 데이터 모델링과 저장을 간소화하는 데 도움이 될 수 있기 때문입니다. 엔터티 중 하나가 다른 엔터티에 문서 배열로 임베드되면 관련 데이터는 단일 문서에 저장되고 단일 쿼리에서 검색할 수 있습니다. 이를 통해 쿼리 성능을 개선하고 데이터 모델링과 저장을 간소화하는 데 도움이 될 수 있습니다.

나는 근데 인정 못하겠음..

### 샤드키 문제

모든 샤드된 컬렉션에는 [샤드 키를](https://www.mongodb.com/docs/manual/reference/glossary/#std-term-shard-key) 지원하는 인덱스가 있어야 **합니다** . 인덱스는 샤드 키의 인덱스이거나 샤드 키가 인덱스의 [접두사 인](https://www.mongodb.com/docs/manual/core/indexes/index-types/index-compound/#std-label-compound-index-prefix) [복합 인덱스 일 수 있습니다.](https://www.mongodb.com/docs/manual/reference/glossary/#std-term-compound-index)

- 컬렉션이 비어 있는 경우, [`sh.shardCollection()`](https://www.mongodb.com/docs/manual/reference/method/sh.shardCollection/#mongodb-method-sh.shardCollection)해당 인덱스가 아직 없으면 샤드 키에 인덱스를 생성합니다.
- 컬렉션이 비어 있지 않으면 .을 사용하기 전에 먼저 인덱스를 만들어야 합니다 [`sh.shardCollection()`.](https://www.mongodb.com/docs/manual/reference/method/sh.shardCollection/#mongodb-method-sh.shardCollection)

샤드 키를 지원하는 유일한 숨겨지지 않은 인덱스인 경우 인덱스를 [삭제](https://www.mongodb.com/docs/manual/reference/method/db.collection.dropIndex/#std-label-collection-drop-index) 하거나 [숨길](https://www.mongodb.com/docs/manual/reference/method/db.collection.hideIndex/#std-label-collection-hide-index) 수 없습니다 .

그리고 그냥 인덱스랑 다르게 거꾸로 순서가 되어 있어도 사용가능한듯 ?

### findAndModify

```tsx
db.orders.findAndModify({
  query: { status: "Pending" },
  update: { $set: { status: "Completed" } }
})
```
